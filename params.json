{
  "name": "Eventuality",
  "tagline": "How I'd like to do CQRS",
  "body": "# Eventuality\r\nThis is simply a POC and my way of writing down my thoughts about how I would want to implement a CQRS system. The focus here is on components/tools and functions that can be interchanged rather than a full framework.\r\n\r\n## components\r\n  * Domain Model (Aggregate)\r\n    > This is the object that represents the state of our model. Only it can change its own state as a result of Commands. Each state change results in an Event.\r\n\r\n  * EventStore\r\n    > A storage facility for events/history/facts. This can be in memory or backed by a database. What I have here is in memory.\r\n\r\n  * EventBus\r\n    > The medium through which facts of state change are shared to interested observers.\r\n\r\n  * EventListeners\r\n    > These are the observers of facts of state changes. They are functions to be invoked when the domain model has changed its state.\r\n\r\n  * Repository\r\n    > A component through which we create and access the domain model.\r\n\r\n  * Commands\r\n    > Objects representing an intent of state change by the user on the domain model.\r\n\r\n  * CommandHandlers\r\n    > Functions with the purpose of communicating the intended state change to the domain model.  \r\n\r\n  * Events  \r\n    > Objects representing a fact of state change in the domain model.\r\n\r\nBased on these definitions of the components, the system should work like this:\r\n\r\n  > CommandHandlers are effectively `CH(Command) -> [...Event]`\r\n\r\n  >Actions the domain model can execute are `A() -> [...Event]`\r\n\r\nThis means every intention to change the state of the domain model results in *n* events (where n = 0 is a failure and n > 0 is success).\r\n\r\n## Examples of usage\r\nOf course, I'll use a Todo application because that's the app any system can build.\r\n\r\n``` coffeescript\r\nEventuality = require 'eventuality'\r\n\r\nTodo = Eventuality.defineAggregate\r\n  name: 'Todo'\r\n  state:\r\n    description: null\r\n    completed: false\r\n  methods:\r\n    complete: ->\r\n      @state.completed = true\r\n      Eventuality.Event(aggregateId: @id, name: 'TodoCompletedEvent', payload: {completed: true}, state: @state)\r\n\r\nTodoCommands =\r\n  CreateTodo: ({id, description }) -> name: 'CreateTodo', message: {id, description}\r\n  MarkAsCompleted: ({ id }) -> name: 'MarkAsCompleted', message: {id}\r\n\r\nTodoEventStore = Eventuality.EventStore()\r\n\r\nTodoRepository = Eventuality.Repository 'Todo', Todo, TodoEventStore\r\n\r\nTodoCommandHandlers =\r\n  CreateTodo: (attrs) -> TodoRepository.add attrs\r\n  MarkAsCompleted: ({ id }) ->\r\n    TodoRepository.load(id).then (todo) ->\r\n      todo.complete()\r\n\r\nTodoEventBus = Eventuality.EventBus()\r\n\r\nTodoCreatedEventListenerToUpdateDB = (event) -> # Update database...\r\nTodoCreatedEventListenerToLogStuff = (event) -> # Do some logging...\r\n\r\nTodoEventBus.registerListeners\r\n  TodoCreatedEvent: [\r\n    TodoCreatedEventListenerToUpdateDB\r\n    TodoCreatedEventListenerToLogStuff\r\n  ]\r\n  TodoCompletedEvent: [\r\n    (event) ->\r\n      # More stuff to be done\r\n  ]\r\n```\r\n\r\n### It _can_(doesn't have to) all come together like so...\r\n``` coffeescript\r\nTodoFlow = Eventuality.Flow\r\n  eventStore: TodoEventStore\r\n  eventBus: TodoEventBus\r\n  commandHandlers: TodoCommandHandlers\r\n\r\n## Later when the user wants to do things...\r\nTodoFlow.dispatch TodoCommands.CreateTodo id: 'todo1', description: 'Create a todo'\r\nTodoFlow.dispatch TodoCommands.MarkAsCompleted id: 'todo1'\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}